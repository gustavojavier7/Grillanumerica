<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grilla Numérica - Secuencias</title>
    <style>
        body {
            font-family: Tahoma, "MS Sans Serif", Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #008080; /* Clásico verde azulado de fondo de escritorio */
            color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden; /* Evitar scroll accidental */
        }
        #main-container {
            display: flex;
            gap: 20px;
            align-items: stretch;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            justify-content: center; /* Centrar los contenedores */
        }
        #game-container {
            display: grid;
            gap: 1px;
            background-color: #c0c0c0;
            padding: 2px;
            border-top: 2px solid #808080;
            border-left: 2px solid #808080;
            border-right: 2px solid #ffffff;
            border-bottom: 2px solid #ffffff;
            box-shadow: inset 1px 1px 0px #000, 1px 1px 0px #fff;
            flex: 0 1 60%;
            aspect-ratio: 1 / 1;
            height: 100%;
            max-height: 90vh; /* Evita que desborde verticalmente en monitores anchos */
            overflow: hidden;
        }
        .cell {
            width: auto;
            height: auto;
            background-color: #c0c0c0;
            border-top: 1px solid #ffffff;
            border-left: 1px solid #ffffff;
            border-right: 1px solid #808080;
            border-bottom: 1px solid #808080;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5vmin; /* Fuente responsiva */
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            color: #000;
            text-shadow: 1px 1px 0px #ffffff;
        }
        .cell.selected {
            background-color: #000080; /* Azul selección Windows */
            color: #ffffff;
            text-shadow: none;
            border: 1px solid #000;
        }
        .cell.matched {
            background-color: #808080;
            color: #ff0000;
            text-shadow: 1px 1px 0px #000;
            border: 1px solid #000;
        }

        @keyframes aiHintPulse1 {
          0%   { outline: 0px solid transparent; filter: brightness(1); }
          50%  { outline: 3px solid #0000FF; filter: brightness(1.3); }
          100% { outline: 0px solid transparent; filter: brightness(1); }
        }
        @keyframes aiHintPulse2 {
          0%   { outline: 0px solid transparent; filter: brightness(1); }
          50%  { outline: 3px solid #FF00FF; filter: brightness(1.3); }
          100% { outline: 0px solid transparent; filter: brightness(1); }
        }
        @keyframes aiHintPulse3 {
          0%   { outline: 0px solid transparent; filter: brightness(1); }
          50%  { outline: 3px solid #00FFFF; filter: brightness(1.3); }
          100% { outline: 0px solid transparent; filter: brightness(1); }
        }
        .cell.ai-hint-1 { animation: aiHintPulse1 1s ease-in-out infinite; z-index: 10; }
        .cell.ai-hint-2 { animation: aiHintPulse2 1s ease-in-out infinite 0.2s; z-index: 9; }
        .cell.ai-hint-3 { animation: aiHintPulse3 1s ease-in-out infinite 0.4s; z-index: 8; }
        
        #ui-container {
            background-color: #c0c0c0;
            border-top: 2px solid #ffffff;
            border-left: 2px solid #ffffff;
            border-right: 2px solid #404040;
            border-bottom: 2px solid #404040;
            width: 250px;
            flex: 0 0 250px;
            display: flex;
            flex-direction: column;
            padding: 2px;
        }
        .window-title {
            background: linear-gradient(90deg, #000080, #1084d0);
            color: white;
            padding: 2px 4px;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        .stat-box {
            margin: 5px 10px;
            padding: 3px;
            background: #fff;
            border-top: 1px solid #808080;
            border-left: 1px solid #808080;
            border-right: 1px solid #ffffff;
            border-bottom: 1px solid #ffffff;
            text-align: right;
        }
        .stat-label { 
            font-size: 10px; 
            color: #000; 
            text-align: left;
            margin-left: 10px;
            margin-top: 2px;
        }
        .stat-value { 
            font-family: 'Courier New', monospace;
            font-size: 16px; 
            font-weight: bold; 
            color: #000; 
        }
        
        button {
            margin: 5px;
            padding: 3px 10px;
            background: #c0c0c0;
            color: black;
            border-top: 2px solid #ffffff;
            border-left: 2px solid #ffffff;
            border-right: 2px solid #404040;
            border-bottom: 2px solid #404040;
            cursor: pointer;
            font-size: 11px;
        }
        button:active {
            border-top: 2px solid #404040;
            border-left: 2px solid #404040;
            border-right: 2px solid #ffffff;
            border-bottom: 2px solid #ffffff;
            padding: 4px 9px 2px 11px;
        }
        
       .pop-item {
            font-size: 11px;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
            color: #000;
        }
        .pop-digit {
            font-weight: bold;
            color: #000080;
        }
        
        #instructions {
            font-size: 10px; 
            padding: 5px; 
            border-top: 1px solid #808080; 
            margin-top: 5px; 
            background: #c0c0c0;
            flex-grow: 1;
        }

        #ai-top-list {
            font-size: 9px;
            margin-top: 5px;
            border-top: 1px dotted #808080;
            padding-top: 4px;
        }
        .ai-top-item {
            display: flex;
            justify-content: space-between;
            padding: 1px 0;
        }
        .ai-color-1 { color: #0000FF; }
        .ai-color-2 { color: #FF00FF; }
        .ai-color-3 { color: #008080; }

        /* Responsividad tipo Grilla */
        @media (max-width: 768px) {
            #main-container {
                flex-direction: column;
                align-items: center;
            }
            #game-container {
                flex: none;
                width: 90vw;
                height: 90vw;
                max-height: none;
            }
            #ui-container {
                flex: none;
                width: 90vw;
            }
            .cell {
                font-size: 4vmin;
            }
        }
    </style>
</head>
<body>

<div id="main-container">
    <div id="game-container"></div>
    
    <div id="ui-container">
        <div class="window-title">
            <span>Estadísticas de Juego</span>
            <div style="background:#c0c0c0; color:black; width:14px; height:12px; line-height:10px; text-align:center; border:1px solid #000; font-size:10px;">X</div>
        </div>
        <div class="stat-label">PUNTAJE ACUMULADO</div>
        <div class="stat-box">
            <div id="score" class="stat-value">00000000</div>
        </div>
        <div class="stat-label">TIEMPO TRANSCURRIDO</div>
        <div class="stat-box">
            <div id="timer" class="stat-value">00:00</div>
        </div>
        <div class="stat-label">MULTIPLICADOR</div>
        <div class="stat-box">
            <div id="combo" class="stat-value">x1</div>
        </div>
        <div class="stat-label">IA-ASSIST (MÁX 3)</div>
        <div class="stat-box" style="text-align:left; min-height:80px;">
          <label style="font-size:11px; display:flex; gap:8px; align-items:center; cursor:pointer;">
            <input type="checkbox" id="aiAssistToggle">
            Activar sugerencias
          </label>
          <div id="aiStatus" style="margin-top:4px; font-size:9px; color:#404040; font-weight:bold;">IA: INACTIVA</div>
          <div id="ai-top-list"></div>
        </div>
        <div class="stat-label">POBLACIÓN</div>
        <div class="stat-box" id="population-list" style="text-align: left; padding: 4px;">
            </div>
        <div style="text-align: center;">
            <button onclick="resetGame()">Reiniciar</button>
        </div>
        <div id="instructions">
            <b>Instrucciones:</b> Forme líneas de 3 en secuencia o iguales.
        </div>
    </div>
</div>

<script>
    const ROWS = 20;
    const COLS = 20;
    let board = [];
    let cellElements = [];
    let selectedCell = null;
    let score = 0;
    let timeElapsed = 0;
    let isProcessing = false;
    let combo = 1;
    let cellCounts = {};

    function updatePopulationList() {
        const container = document.getElementById('population-list');
        if (!container) return;
        container.innerHTML = '';
        const totalCells = ROWS * COLS;
        
        for (let i = 0; i <= 9; i++) {
            const count = cellCounts[i] || 0;
            const percentage = ((count / totalCells) * 100).toFixed(1);
            
            const div = document.createElement('div');
            div.className = 'pop-item';
            div.innerHTML = `<span class="pop-digit">Nº ${i}:</span> <span>${count} (${percentage}%)</span>`;
            container.appendChild(div);
        }
    }

    function initCellCounts() {
        for (let i = 0; i <= 9; i++) cellCounts[i] = 0;
    }

    /* Se reemplaza la medición manual por la lectura directa del DOM */
    function getCellMetrics() {
        if (cellElements[0] && cellElements[0][0]) {
            const rect = cellElements[0][0].getBoundingClientRect();
            const gap = parseFloat(getComputedStyle(document.getElementById('game-container')).gap) || 1;
            return rect.height + gap;
        }
        return 26; // Fallback
    }

    // getWeightedValue: DETERMINÍSTICA para rellenos post-cascada
    function getWeightedValue(r, c) {
        const digits = Array.from({length: 10}, (_, i) => i);
        // Ordenamiento estable: por cuenta ascendente, luego por valor de dígito
        digits.sort((a, b) => (cellCounts[a] - cellCounts[b]) || (a - b));

        for (const val of digits) {
            let isSafe = true;
            const dirs = [[0,1], [1,0], [1,1], [1,-1]];
            for (const [dr, dc] of dirs) {
                const checks = [
                    [[r + dr, c + dc], [r + 2 * dr, c + 2 * dc]],
                    [[r - dr, c - dc], [r + dr, c + dc]],        
                    [[r - 2 * dr, c - 2 * dc], [r - dr, c - dc]] 
                ];
                for (const [[r2, c2], [r3, c3]] of checks) {
                    if (r2 >= 0 && r2 < ROWS && c2 >= 0 && c2 < COLS &&
                        r3 >= 0 && r3 < ROWS && c3 >= 0 && c3 < COLS) {
                        if (board[r2] && board[r3]) {
                            const v2 = board[r2][c2];
                            const v3 = board[r3][c3];
                            if (v2 !== undefined && v2 !== -1 && v3 !== undefined && v3 !== -1) {
                                if (val === v2 && v2 === v3) { isSafe = false; break; }
                                if ((v2 === val + 1 && v3 === val + 2) || (v2 === val - 1 && v3 === val + 1) || (v2 === val - 2 && v3 === val - 1)) { isSafe = false; break; }
                                if ((v2 === val - 1 && v3 === val - 2) || (v2 === val + 1 && v3 === val - 1) || (v2 === val + 2 && v3 === val + 1)) { isSafe = false; break; }
                            }
                        }
                    }
                }
                if (!isSafe) break;
            }
            if (isSafe) return val;
        }
        return digits[0]; 
    }

    // getRandomWeightedValue: AL AZAR para el inicio del juego
    function getRandomWeightedValue(r, c) {
        const digits = Array.from({length: 10}, (_, i) => i);
        // Mezclar dígitos para aleatoriedad
        for (let i = digits.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [digits[i], digits[j]] = [digits[j], digits[i]];
        }

        for (const val of digits) {
            let isSafe = true;
            const dirs = [[0,1], [1,0], [1,1], [1,-1]];
            for (const [dr, dc] of dirs) {
                const checks = [
                    [[r + dr, c + dc], [r + 2 * dr, c + 2 * dc]],
                    [[r - dr, c - dc], [r + dr, c + dc]],        
                    [[r - 2 * dr, c - 2 * dc], [r - dr, c - dc]] 
                ];
                for (const [[r2, c2], [r3, c3]] of checks) {
                    if (r2 >= 0 && r2 < ROWS && c2 >= 0 && c2 < COLS &&
                        r3 >= 0 && r3 < ROWS && c3 >= 0 && c3 < COLS) {
                        if (board[r2] && board[r3]) {
                            const v2 = board[r2][c2];
                            const v3 = board[r3][c3];
                            if (v2 !== undefined && v2 !== -1 && v3 !== undefined && v3 !== -1) {
                                if (val === v2 && v2 === v3) { isSafe = false; break; }
                                if ((v2 === val + 1 && v3 === val + 2) || (v2 === val - 1 && v3 === val + 1) || (v2 === val - 2 && v3 === val - 1)) { isSafe = false; break; }
                                if ((v2 === val - 1 && v3 === val - 2) || (v2 === val + 1 && v3 === val - 1) || (v2 === val + 2 && v3 === val + 1)) { isSafe = false; break; }
                            }
                        }
                    }
                }
                if (!isSafe) break;
            }
            if (isSafe) return val;
        }
        return Math.floor(Math.random() * 10);
    }

    function init() {
        initCellCounts();
        
        const container = document.getElementById('game-container');
        /* Generación de grilla dinámica desde JS usando CSS Grid */
        container.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
        container.style.gridTemplateRows = `repeat(${ROWS}, 1fr)`;
        container.innerHTML = ''; 
        
        for (let r = 0; r < ROWS; r++) {
            board[r] = [];
            cellElements[r] = [];
            for (let c = 0; c < COLS; c++) {
                // PRIMER LLENADO: AL AZAR
                const val = getRandomWeightedValue(r, c);
                board[r][c] = val;
                cellCounts[val]++;
                
                const div = document.createElement('div');
                div.className = `cell n${val}`;
                div.textContent = val;
                div.onclick = () => handleCellClick(r, c);
                container.appendChild(div);
                cellElements[r][c] = div;
            }
        }
        startTimer();
        checkAndRemoveMatches();

        const toggle = document.getElementById('aiAssistToggle');
        if (toggle) {
          toggle.addEventListener('change', (e) => setAiEnabled(e.target.checked));
        }
    }

    function handleCellClick(r, c) {
        if (isProcessing) return;
        
        if (!selectedCell) {
            selectedCell = {r, c};
            cellElements[r][c].classList.add('selected');
        } else {
            const dr = Math.abs(r - selectedCell.r);
            const dc = Math.abs(c - selectedCell.c);
            
            if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
                // stop_blink_on_confirm: detener IA y limpiar tablero
                stopAiSearch();
                clearAiHints();
                
                swap(selectedCell.r, selectedCell.c, r, c);
                checkAndRemoveMatches(true);
            }
            
            cellElements[selectedCell.r][selectedCell.c].classList.remove('selected');
            selectedCell = null;
        }
    }

    function swap(r1, c1, r2, c2) {
        const temp = board[r1][c1];
        board[r1][c1] = board[r2][c2];
        board[r2][c2] = temp;
        updateCell(r1, c1);
        updateCell(r2, c2);
    }

    function updateCell(r, c) {
        const val = board[r][c];
        cellElements[r][c].className = `cell n${val}`;
        cellElements[r][c].textContent = val;
    }

    function addFallAnimation(cell, delay = 0, initialOffset = 0, isNewCell = false) {
        cell.style.transition = 'none';
        cell.style.transform = `translateY(${initialOffset}px)`;
        if (isNewCell) cell.style.opacity = '0';
        void cell.offsetWidth; 

        cell.style.transition = `transform 0.2s cubic-bezier(0.42, 0, 1.0, 1.0) ${delay}s, opacity 0.2s linear ${delay}s`;
        cell.style.transform = 'translateY(0)';
        if (isNewCell) cell.style.opacity = '1';

        const transitionEndHandler = () => {
            cell.style.transition = '';
            cell.style.transform = '';
            cell.style.opacity = '';
            cell.removeEventListener('transitionend', transitionEndHandler);
        };
        cell.addEventListener('transitionend', transitionEndHandler);
    }

    async function checkAndRemoveMatches(isManualMove = false) {
        isProcessing = true;
        let matchedPositions = new Set();
        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                directions.forEach(([dr, dc]) => {
                    const r2 = r + dr, c2 = c + dc;
                    const r3 = r + 2 * dr, c3 = c + 2 * dc;

                    if (r3 >= 0 && r3 < ROWS && c3 >= 0 && c3 < COLS) {
                        const v1 = board[r][c];
                        const v2 = board[r2][c2];
                        const v3 = board[r3][c3];

                        if ((v2 === v1 + 1 && v3 === v2 + 1) || (v2 === v1 - 1 && v3 === v2 - 1) || (v1 === v2 && v2 === v3)) {
                            matchedPositions.add(`${r},${c}`);
                            matchedPositions.add(`${r2},${c2}`);
                            matchedPositions.add(`${r3},${c3}`);
                        }
                    }
                });
            }
        }

        if (matchedPositions.size > 0) {
            matchedPositions.forEach(pos => {
                const [r, c] = pos.split(',').map(Number);
                cellElements[r][c].classList.add('matched');
            });

            await new Promise(res => setTimeout(res, 600));

            score += matchedPositions.size * 10 * combo;
            document.getElementById('score').textContent = score.toString().padStart(8, '0');
            
            matchedPositions.forEach(pos => {
                const [r, c] = pos.split(',').map(Number);
                const val = board[r][c];
                if (val !== -1) cellCounts[val]--; 
                board[r][c] = -1;
                cellElements[r][c].classList.remove('matched');
                cellElements[r][c].textContent = '';
                cellElements[r][c].className = 'cell';
            });

            await applyGravity();
            combo++;
            document.getElementById('combo').textContent = `x${combo}`;
            
            setTimeout(() => checkAndRemoveMatches(), 300);
        } else {
            isProcessing = false;
            combo = 1;
            document.getElementById('combo').textContent = `x1`;
            updatePopulationList();
            
            if (aiEnabled) startAiSearch();
        }
    }

    async function applyGravity() {
        let maxDelay = 0;
        const CELL_SIZE_REAL = getCellMetrics();

        for (let c = 0; c < COLS; c++) {
            let emptySpaces = 0;
            let delayIndex = 0;

            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][c] === -1) {
                    emptySpaces++;
                } else if (emptySpaces > 0) {
                    const oldR = r;
                    const newR = r + emptySpaces;
                    const val = board[oldR][c];

                    board[newR][c] = val;
                    board[oldR][c] = -1;

                    updateCell(newR, c);
                    cellElements[oldR][c].textContent = '';
                    cellElements[oldR][c].className = 'cell';

                    const delay = delayIndex * 0.02;
                    addFallAnimation(cellElements[newR][c], delay, -emptySpaces * CELL_SIZE_REAL, false);
                    maxDelay = Math.max(maxDelay, delay);
                    delayIndex++;
                }
            }

            for (let r = 0; r < emptySpaces; r++) {
                // A PARTIR DE AQUÍ (RELLENO POST-CASCADA): DETERMINÍSTICO
                const val = getWeightedValue(r, c);
                board[r][c] = val;
                cellCounts[val]++; 
                updateCell(r, c);
                
                const delay = delayIndex * 0.02;
                addFallAnimation(cellElements[r][c], delay, -emptySpaces * CELL_SIZE_REAL, true);
                maxDelay = Math.max(maxDelay, delay);
                delayIndex++;
            }
        }
        await new Promise(res => setTimeout(res, (maxDelay + 0.2) * 1000));
    }

    function renderAll() {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                updateCell(r, c);
                cellElements[r][c].classList.remove('matched');
            }
        }
    }

    function startTimer() {
        setInterval(() => {
            timeElapsed++;
            const mins = Math.floor(timeElapsed / 60).toString().padStart(2, '0');
            const secs = (timeElapsed % 60).toString().padStart(2, '0');
            document.getElementById('timer').textContent = `${mins}:${secs}`;
        }, 1000);
    }

    function resetGame() {
        location.reload();
    }

    // =======================
    // IA-ASSIST (mejor cascada)
    // =======================
    let aiEnabled = false;
    let aiRunning = false;
    let aiAbort = false;
    let aiTopSwaps = []; // Almacena hasta 3 mejores swaps
    let gameEnded = false;

    function updateAiStatus(text) {
        const el = document.getElementById('aiStatus');
        if (el) el.textContent = `IA: ${text}`;
    }

    function setAiEnabled(v) {
      aiEnabled = v;
      if (!aiEnabled) {
        stopAiSearch();
        clearAiHints();
        updateAiStatus('INACTIVA');
        document.getElementById('ai-top-list').innerHTML = '';
      } else {
        if (!isProcessing) startAiSearch();
      }
    }

    function stopAiSearch() {
      aiAbort = true;
      aiRunning = false;
    }

    // Asegura limpieza total de cualquier clase de parpadeo
    function clearAiHints() {
      const hints = document.querySelectorAll('.cell.ai-hint-1, .cell.ai-hint-2, .cell.ai-hint-3');
      hints.forEach(el => el.classList.remove('ai-hint-1', 'ai-hint-2', 'ai-hint-3'));
    }

    // blink_top_3_swaps: Aplica los parpadeos exclusivamente al top 3 actual
    function blink_top_3_swaps() {
      clearAiHints();
      const listEl = document.getElementById('ai-top-list');
      listEl.innerHTML = '';
      
      aiTopSwaps.forEach((swap, index) => {
        const colorClass = `ai-color-${index + 1}`;
        const hintClass = `ai-hint-${index + 1}`;
        
        if (cellElements[swap.r1]?.[swap.c1]) cellElements[swap.r1][swap.c1].classList.add(hintClass);
        if (cellElements[swap.r2]?.[swap.c2]) cellElements[swap.r2][swap.c2].classList.add(hintClass);
        
        const item = document.createElement('div');
        item.className = 'ai-top-item';
        item.innerHTML = `<span class="${colorClass}">Pos ${index+1}: (${swap.r1},${swap.c1})</span> <b>C:${swap.cycles}</b>`;
        listEl.appendChild(item);
      });
    }

    // --- Simulación pura (sin DOM) ---
    function cloneBoard(src) {
      return src.map(row => row.slice());
    }

    function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }

    // Versión DETERMINÍSTICA de getWeightedValue para la SIMULACIÓN de la IA
    function getWeightedValueSim(r, c, bd, counts) {
        const digits = Array.from({length: 10}, (_, i) => i);
        // Ordenamiento estable idéntico al juego real
        digits.sort((a, b) => (counts[a] - counts[b]) || (a - b));

        for (const val of digits) {
            let isSafe = true;
            const dirs = [[0,1], [1,0], [1,1], [1,-1]];
            for (const [dr, dc] of dirs) {
                const checks = [
                    [[r + dr, c + dc], [r + 2 * dr, c + 2 * dc]],
                    [[r - dr, c - dc], [r + dr, c + dc]],        
                    [[r - 2 * dr, c - 2 * dc], [r - dr, c - dc]] 
                ];
                for (const [[r2, c2], [r3, c3]] of checks) {
                    if (inBounds(r2,c2) && inBounds(r3,c3)) {
                        const v2 = bd[r2][c2];
                        const v3 = bd[r3][c3];
                        if (v2 !== -1 && v3 !== -1) {
                            if (val === v2 && v2 === v3) { isSafe = false; break; }
                            if ((v2 === val + 1 && v3 === val + 2) || (v2 === val - 1 && v3 === val + 1) || (v2 === val - 2 && v3 === val - 1)) { isSafe = false; break; }
                            if ((v2 === val - 1 && v3 === val - 2) || (v2 === val + 1 && v3 === val - 1) || (v2 === val + 2 && v3 === val + 1)) { isSafe = false; break; }
                        }
                    }
                }
                if (!isSafe) break;
            }
            if (isSafe) return val;
        }
        return digits[0]; 
    }

    function findMatchesSim(bd) {
      const matched = new Set();
      const dirs = [[0,1],[1,0],[1,1],[1,-1]];
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLS;c++){
          const v1 = bd[r][c];
          if (v1 === -1) continue;
          for (const [dr,dc] of dirs){
            const r2=r+dr, c2=c+dc, r3=r+2*dr, c3=c+2*dc;
            if (!inBounds(r3,c3)) continue;
            const v2=bd[r2][c2], v3=bd[r3][c3];
            if (v2===-1 || v3===-1) continue;

            const seqUp   = (v2 === v1 + 1 && v3 === v2 + 1);
            const seqDown = (v2 === v1 - 1 && v3 === v2 - 1);
            const equal3  = (v1 === v2 && v2 === v3);

            if (seqUp || seqDown || equal3){
              matched.add(`${r},${c}`);
              matched.add(`${r2},${c2}`);
              matched.add(`${r3},${c3}`);
            }
          }
        }
      }
      return matched;
    }

    function applyGravitySim(bd, counts) {
      for (let c=0;c<COLS;c++){
        let write = ROWS-1;
        for (let r=ROWS-1;r>=0;r--){
          if (bd[r][c] !== -1){
            bd[write][c] = bd[r][c];
            if (write !== r) bd[r][c] = -1;
            write--;
          }
        }
        for (let r=write;r>=0;r--){
          const val = getWeightedValueSim(r, c, bd, counts);
          bd[r][c] = val;
          counts[val]++;
        }
      }
    }

    function simulateSwapCycles(boardSnapshot, countsSnapshot, r1,c1,r2,c2, maxCyclesCap=30) {
      const bd = cloneBoard(boardSnapshot);
      const counts = {...countsSnapshot};
      const t = bd[r1][c1]; bd[r1][c1] = bd[r2][c2]; bd[r2][c2] = t;
      
      let cycles = 0;
      for (let iter=0; iter<maxCyclesCap; iter++){
        const matches = findMatchesSim(bd);
        if (matches.size === 0) break;
        cycles++;
        for (const pos of matches){
          const [r,c] = pos.split(',').map(Number);
          counts[bd[r][c]]--;
          bd[r][c] = -1;
        }
        applyGravitySim(bd, counts);
      }
      return cycles;
    }

    function enumerateAdjacentSwaps() {
      const swaps = [];
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLS;c++){
          if (c+1<COLS) swaps.push([r,c,r,c+1]);
          if (r+1<ROWS) swaps.push([r,c,r+1,c]);
        }
      }
      return swaps;
    }

    async function startAiSearch() {
      if (!aiEnabled || isProcessing || gameEnded) return;
      if (aiRunning) return;

      aiAbort = false;
      aiRunning = true;
      aiTopSwaps = [];
      updateAiStatus('BUSCANDO...');
      document.getElementById('ai-top-list').innerHTML = '';

      const snapshot = cloneBoard(board);
      const countsSnapshot = {...cellCounts};
      const swaps = enumerateAdjacentSwaps();

      let idx = 0;
      const batchSize = 12; // Ajustado para rendimiento

      const tick = () => {
        if (aiAbort || !aiEnabled || isProcessing || gameEnded) {
          aiRunning = false;
          if (!aiEnabled) updateAiStatus('INACTIVA');
          return;
        }

        const end = Math.min(swaps.length, idx + batchSize);
        for (; idx<end; idx++){
          const [r1,c1,r2,c2] = swaps[idx];
          const cycles = simulateSwapCycles(snapshot, countsSnapshot, r1,c1,r2,c2);
          
          if (cycles > 0) {
            const currentSwap = { cycles, r1, c1, r2, c2 };
            aiTopSwaps.push(currentSwap);
            // Ordenar por ciclos descendente y mantener solo top 3
            aiTopSwaps.sort((a, b) => (b.cycles - a.cycles) || (a.r1 - b.r1) || (a.c1 - b.c1));
            if (aiTopSwaps.length > 3) aiTopSwaps.pop();
            
            blink_top_3_swaps();
          }
        }

        if (idx >= swaps.length){
          aiRunning = false;
          updateAiStatus('LISTO');
          if (aiTopSwaps.length === 0) {
              document.getElementById('ai-top-list').innerHTML = '<div style="font-size:8px;color:#800000">No se hallaron matches.</div>';
          }
          return;
        }
        setTimeout(tick, 0);
      };
      tick();
    }

    // Se elimina el EventListener de resize porque el CSS maneja la responsividad dinámicamente
    window.onload = init;
</script>

</body>
</html>

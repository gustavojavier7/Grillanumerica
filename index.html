<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grilla Numérica - Secuencias</title>
    <style>
        body {
            font-family: Tahoma, "MS Sans Serif", Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #008080; /* Clásico verde azulado de fondo de escritorio */
            color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden; /* Evitar scroll accidental */
        }
        #main-container {
            display: flex;
            gap: 20px;
            align-items: stretch;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            justify-content: center; /* Centrar los contenedores */
        }
        #game-container {
            display: grid;
            gap: 1px;
            background-color: #c0c0c0;
            padding: 2px;
            border-top: 2px solid #808080;
            border-left: 2px solid #808080;
            border-right: 2px solid #ffffff;
            border-bottom: 2px solid #ffffff;
            box-shadow: inset 1px 1px 0px #000, 1px 1px 0px #fff;
            flex: 0 1 60%;
            aspect-ratio: 1 / 1;
            height: 100%;
            max-height: 90vh; /* Evita que desborde verticalmente en monitores anchos */
            overflow: hidden;
        }
        .cell {
            width: auto;
            height: auto;
            background-color: #c0c0c0;
            border-top: 1px solid #ffffff;
            border-left: 1px solid #ffffff;
            border-right: 1px solid #808080;
            border-bottom: 1px solid #808080;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5vmin; /* Fuente responsiva */
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            color: #000;
            text-shadow: 1px 1px 0px #ffffff;
        }
        .cell.selected {
            background-color: #000080; /* Azul selección Windows */
            color: #ffffff;
            text-shadow: none;
            border: 1px solid #000;
        }
        .cell.matched {
            background-color: #808080;
            color: #ff0000;
            text-shadow: 1px 1px 0px #000;
            border: 1px solid #000;
        }
        
        #ui-container {
            background-color: #c0c0c0;
            border-top: 2px solid #ffffff;
            border-left: 2px solid #ffffff;
            border-right: 2px solid #404040;
            border-bottom: 2px solid #404040;
            width: 250px;
            flex: 0 0 250px;
            display: flex;
            flex-direction: column;
            padding: 2px;
        }
        .window-title {
            background: linear-gradient(90deg, #000080, #1084d0);
            color: white;
            padding: 2px 4px;
            font-size: 11px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        .stat-box {
            margin: 5px 10px;
            padding: 3px;
            background: #fff;
            border-top: 1px solid #808080;
            border-left: 1px solid #808080;
            border-right: 1px solid #ffffff;
            border-bottom: 1px solid #ffffff;
            text-align: right;
        }
        .stat-label { 
            font-size: 10px; 
            color: #000; 
            text-align: left;
            margin-left: 10px;
            margin-top: 2px;
        }
        .stat-value { 
            font-family: 'Courier New', monospace;
            font-size: 16px; 
            font-weight: bold; 
            color: #000; 
        }
        
        button {
            margin: 5px;
            padding: 3px 10px;
            background: #c0c0c0;
            color: black;
            border-top: 2px solid #ffffff;
            border-left: 2px solid #ffffff;
            border-right: 2px solid #404040;
            border-bottom: 2px solid #404040;
            cursor: pointer;
            font-size: 11px;
        }
        button:active {
            border-top: 2px solid #404040;
            border-left: 2px solid #404040;
            border-right: 2px solid #ffffff;
            border-bottom: 2px solid #ffffff;
            padding: 4px 9px 2px 11px;
        }
        
        #instructions {
            font-size: 10px; 
            padding: 5px; 
            border-top: 1px solid #808080; 
            margin-top: 5px; 
            background: #c0c0c0;
            flex-grow: 1;
        }

        /* Responsividad tipo Grilla */
        @media (max-width: 768px) {
            #main-container {
                flex-direction: column;
                align-items: center;
            }
            #game-container {
                flex: none;
                width: 90vw;
                height: 90vw;
                max-height: none;
            }
            #ui-container {
                flex: none;
                width: 90vw;
            }
            .cell {
                font-size: 4vmin;
            }
        }
    </style>
</head>
<body>

<div id="main-container">
    <div id="game-container"></div>
    
    <div id="ui-container">
        <div class="window-title">
            <span>Estadísticas de Juego</span>
            <div style="background:#c0c0c0; color:black; width:14px; height:12px; line-height:10px; text-align:center; border:1px solid #000; font-size:10px;">X</div>
        </div>
        <div class="stat-label">PUNTAJE ACUMULADO</div>
        <div class="stat-box">
            <div id="score" class="stat-value">00000000</div>
        </div>
        <div class="stat-label">TIEMPO RESTANTE</div>
        <div class="stat-box">
            <div id="timer" class="stat-value">01:00</div>
        </div>
        <div class="stat-label">MULTIPLICADOR</div>
        <div class="stat-box">
            <div id="combo" class="stat-value">x1</div>
        </div>
        <div style="text-align: center;">
            <button onclick="resetGame()">Reiniciar</button>
        </div>
        <div id="instructions">
            <b>Instrucciones:</b> Forme líneas de 3 en secuencia o iguales.
        </div>
    </div>
</div>

<script>
    const ROWS = 20;
    const COLS = 20;
    let board = [];
    let cellElements = [];
    let selectedCell = null;
    let score = 0;
    let timeLeft = 60;
    let isProcessing = false;
    let combo = 1;
    let cellCounts = {};

    function initCellCounts() {
        for (let i = 0; i <= 9; i++) cellCounts[i] = 0;
    }

    /* Se reemplaza la medición manual por la lectura directa del DOM */
    function getCellMetrics() {
        if (cellElements[0] && cellElements[0][0]) {
            const rect = cellElements[0][0].getBoundingClientRect();
            const gap = parseFloat(getComputedStyle(document.getElementById('game-container')).gap) || 1;
            return rect.height + gap;
        }
        return 26; // Fallback
    }

    function getWeightedValue(r, c) {
        const sortedDigits = Array.from({length: 10}, (_, i) => i).sort((a, b) => cellCounts[a] - cellCounts[b]);

        for (const val of sortedDigits) {
            let isSafe = true;
            const dirs = [[0,1], [1,0], [1,1], [1,-1]];
            
            for (const [dr, dc] of dirs) {
                const checks = [
                    [[r + dr, c + dc], [r + 2 * dr, c + 2 * dc]],
                    [[r - dr, c - dc], [r + dr, c + dc]],        
                    [[r - 2 * dr, c - 2 * dc], [r - dr, c - dc]] 
                ];

                for (const [[r2, c2], [r3, c3]] of checks) {
                    if (r2 >= 0 && r2 < ROWS && c2 >= 0 && c2 < COLS &&
                        r3 >= 0 && r3 < ROWS && c3 >= 0 && c3 < COLS) {
                        
                        if (board[r2] && board[r3]) {
                            const v2 = board[r2][c2];
                            const v3 = board[r3][c3];
                            
                            if (v2 !== undefined && v2 !== -1 && v3 !== undefined && v3 !== -1) {
                                if (val === v2 && v2 === v3) { isSafe = false; break; }
                                if ((v2 === val + 1 && v3 === val + 2) || (v2 === val - 1 && v3 === val + 1) || (v2 === val - 2 && v3 === val - 1)) { isSafe = false; break; }
                                if ((v2 === val - 1 && v3 === val - 2) || (v2 === val + 1 && v3 === val - 1) || (v2 === val + 2 && v3 === val + 1)) { isSafe = false; break; }
                            }
                        }
                    }
                }
                if (!isSafe) break;
            }
            if (isSafe) return val;
        }
        return sortedDigits[0]; 
    }

    function init() {
        initCellCounts();
        
        const container = document.getElementById('game-container');
        /* Generación de grilla dinámica desde JS usando CSS Grid */
        container.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
        container.style.gridTemplateRows = `repeat(${ROWS}, 1fr)`;
        container.innerHTML = ''; 
        
        for (let r = 0; r < ROWS; r++) {
            board[r] = [];
            cellElements[r] = [];
            for (let c = 0; c < COLS; c++) {
                const val = getWeightedValue(r, c);
                board[r][c] = val;
                cellCounts[val]++;
                
                const div = document.createElement('div');
                div.className = `cell n${val}`;
                div.textContent = val;
                div.onclick = () => handleCellClick(r, c);
                container.appendChild(div);
                cellElements[r][c] = div;
            }
        }
        startTimer();
        checkAndRemoveMatches();
    }

    function handleCellClick(r, c) {
        if (isProcessing) return;
        
        if (!selectedCell) {
            selectedCell = {r, c};
            cellElements[r][c].classList.add('selected');
        } else {
            const dr = Math.abs(r - selectedCell.r);
            const dc = Math.abs(c - selectedCell.c);
            
            if ((dr === 1 && dc === 0) || (dr === 0 && dc === 1)) {
                swap(selectedCell.r, selectedCell.c, r, c);
                checkAndRemoveMatches(true);
            }
            
            cellElements[selectedCell.r][selectedCell.c].classList.remove('selected');
            selectedCell = null;
        }
    }

    function swap(r1, c1, r2, c2) {
        const temp = board[r1][c1];
        board[r1][c1] = board[r2][c2];
        board[r2][c2] = temp;
        updateCell(r1, c1);
        updateCell(r2, c2);
    }

    function updateCell(r, c) {
        const val = board[r][c];
        cellElements[r][c].className = `cell n${val}`;
        cellElements[r][c].textContent = val;
    }

    function addFallAnimation(cell, delay = 0, initialOffset = 0, isNewCell = false) {
        cell.style.transition = 'none';
        cell.style.transform = `translateY(${initialOffset}px)`;
        if (isNewCell) cell.style.opacity = '0';
        void cell.offsetWidth; 

        cell.style.transition = `transform 0.2s cubic-bezier(0.42, 0, 1.0, 1.0) ${delay}s, opacity 0.2s linear ${delay}s`;
        cell.style.transform = 'translateY(0)';
        if (isNewCell) cell.style.opacity = '1';

        const transitionEndHandler = () => {
            cell.style.transition = '';
            cell.style.transform = '';
            cell.style.opacity = '';
            cell.removeEventListener('transitionend', transitionEndHandler);
        };
        cell.addEventListener('transitionend', transitionEndHandler);
    }

    async function checkAndRemoveMatches(isManualMove = false) {
        isProcessing = true;
        let matchedPositions = new Set();
        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                directions.forEach(([dr, dc]) => {
                    const r2 = r + dr, c2 = c + dc;
                    const r3 = r + 2 * dr, c3 = c + 2 * dc;

                    if (r3 >= 0 && r3 < ROWS && c3 >= 0 && c3 < COLS) {
                        const v1 = board[r][c];
                        const v2 = board[r2][c2];
                        const v3 = board[r3][c3];

                        if ((v2 === v1 + 1 && v3 === v2 + 1) || (v2 === v1 - 1 && v3 === v2 - 1) || (v1 === v2 && v2 === v3)) {
                            matchedPositions.add(`${r},${c}`);
                            matchedPositions.add(`${r2},${c2}`);
                            matchedPositions.add(`${r3},${c3}`);
                        }
                    }
                });
            }
        }

        if (matchedPositions.size > 0) {
            matchedPositions.forEach(pos => {
                const [r, c] = pos.split(',').map(Number);
                cellElements[r][c].classList.add('matched');
            });

            await new Promise(res => setTimeout(res, 600));

            score += matchedPositions.size * 10 * combo;
            document.getElementById('score').textContent = score.toString().padStart(8, '0');
            
            if (isManualMove) {
                timeLeft += Math.floor(matchedPositions.size / 2);
            }

            matchedPositions.forEach(pos => {
                const [r, c] = pos.split(',').map(Number);
                const val = board[r][c];
                if (val !== -1) cellCounts[val]--; 
                board[r][c] = -1;
                cellElements[r][c].classList.remove('matched');
                cellElements[r][c].textContent = '';
                cellElements[r][c].className = 'cell';
            });

            await applyGravity();
            combo++;
            document.getElementById('combo').textContent = `x${combo}`;
            
            setTimeout(() => checkAndRemoveMatches(), 300);
        } else {
            isProcessing = false;
            combo = 1;
            document.getElementById('combo').textContent = `x1`;
        }
    }

    async function applyGravity() {
        let maxDelay = 0;
        const CELL_SIZE_REAL = getCellMetrics();

        for (let c = 0; c < COLS; c++) {
            let emptySpaces = 0;
            let delayIndex = 0;

            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r][c] === -1) {
                    emptySpaces++;
                } else if (emptySpaces > 0) {
                    const oldR = r;
                    const newR = r + emptySpaces;
                    const val = board[oldR][c];

                    board[newR][c] = val;
                    board[oldR][c] = -1;

                    updateCell(newR, c);
                    cellElements[oldR][c].textContent = '';
                    cellElements[oldR][c].className = 'cell';

                    const delay = delayIndex * 0.02;
                    addFallAnimation(cellElements[newR][c], delay, -emptySpaces * CELL_SIZE_REAL, false);
                    maxDelay = Math.max(maxDelay, delay);
                    delayIndex++;
                }
            }

            for (let r = 0; r < emptySpaces; r++) {
                const val = getWeightedValue(r, c);
                board[r][c] = val;
                cellCounts[val]++; 
                updateCell(r, c);
                
                const delay = delayIndex * 0.02;
                addFallAnimation(cellElements[r][c], delay, -emptySpaces * CELL_SIZE_REAL, true);
                maxDelay = Math.max(maxDelay, delay);
                delayIndex++;
            }
        }
        await new Promise(res => setTimeout(res, (maxDelay + 0.2) * 1000));
    }

    function renderAll() {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                updateCell(r, c);
                cellElements[r][c].classList.remove('matched');
            }
        }
    }

    function startTimer() {
        const interval = setInterval(() => {
            if (timeLeft <= 0) {
                clearInterval(interval);
                alert("Fin del tiempo! Puntaje final: " + score);
                return;
            }
            timeLeft--;
            const mins = Math.floor(timeLeft / 60).toString().padStart(2, '0');
            const secs = (timeLeft % 60).toString().padStart(2, '0');
            document.getElementById('timer').textContent = `${mins}:${secs}`;
        }, 1000);
    }

    function resetGame() {
        location.reload();
    }

    // Se elimina el EventListener de resize porque el CSS maneja la responsividad dinámicamente
    window.onload = init;
</script>

</body>
</html>
